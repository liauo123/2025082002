<!DOCTYPE html>
<html lang="zh-Hant">
<head>
  <meta charset="UTF-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no" />
  <title>é›™äººç¬‘å®¹å°æ±ºï¼ˆåœ“ç’°é¡¯ç¤ºï½œ2Ã—3 ç…§ç‰‡ç‰†ï¼‰</title>
  <style>
    :root { --bg:#0b1020; --panel:#11162a; --ink:#e6eefc; --muted:#8ea1c0; --accent:#61dafb; --win:#35e085; --lose:#ff5c7a; }
    * { box-sizing: border-box; }
    body { margin:0; font-family: system-ui, -apple-system, "Microsoft JhengHei", Segoe UI, Roboto, Helvetica, Arial, sans-serif; background: var(--bg); color: var(--ink); }
    header { padding: 14px 16px; background: linear-gradient(180deg, #0f1630, #0b1020); position: sticky; top:0; z-index: 5; border-bottom: 1px solid #1b2441; }
    header h1 { margin:0; font-size: 20px; letter-spacing: .5px; }
    .wrap { padding: 16px; display: grid; gap: 16px; }
    .grid { display: grid; gap: 16px; grid-template-columns: 1fr; }
    @media (min-width: 1150px) { .grid { grid-template-columns: 2fr 1fr; } }

    .card { background: var(--panel); border:1px solid #1b2441; border-radius: 16px; padding: 12px; box-shadow: 0 10px 30px rgba(0,0,0,.25); }
    .videoWrap { position: relative; border-radius: 12px; overflow: hidden; }
    video, canvas { display: block; width: 100%; height: auto; }
    video { filter: saturate(1.05); background: #000; }
    canvas.overlay { position: absolute; left:0; top:0; pointer-events: none; }
    .mirror { transform: scaleX(-1); }

    .row { display:flex; gap:10px; align-items:center; flex-wrap: wrap; }
    .pill { padding: 8px 12px; border-radius: 999px; background: #0e1a33; border:1px solid #1b2a55; color: var(--ink); font-size: 14px; }
    .btn { cursor:pointer; padding:10px 14px; border-radius:12px; border:1px solid #25407a; background:#14244b; color:#d9e6ff; font-weight:600; }
    .btn:disabled { opacity:.6; cursor:not-allowed; }
    .pill select { background:transparent; color:var(--ink); border:none; font:inherit; }

    .hud { display:grid; grid-template-columns: repeat(3, 1fr); gap:10px; margin-top:10px; }
    .hudItem { background:#0e1631; border:1px solid #22356c; border-radius:12px; padding:10px; text-align:center; }
    .hudItem b { font-size:20px; }

    #toast { position: fixed; left: 50%; bottom: 18px; transform: translateX(-50%); background:#0f1c38; color:#eaf3ff; border:1px solid #233a70; border-radius: 12px; padding:10px 14px; box-shadow:0 12px 30px rgba(0,0,0,.35); opacity:0; pointer-events:none; transition: opacity .25s ease; }
    #toast.show { opacity:1; }

    /* å³å´ 2Ã—3 ç…§ç‰‡ç‰† */
    .gallery { display:grid; grid-template-columns:repeat(2,1fr); grid-template-rows:repeat(3,auto); gap:10px; }
    .shot { position:relative; width:100%; aspect-ratio:4/3; background:#000; border:1px solid #22356c; border-radius:10px; overflow:hidden; }
    .shot img { width:100%; height:100%; object-fit:cover; display:block; opacity:0; transition:opacity .25s ease; }
    .shot .cap { position:absolute; left:6px; bottom:6px; padding:2px 6px; font-size:12px; background:rgba(0,0,0,.45); border:1px solid rgba(255,255,255,.15); border-radius:6px; color:#e6eefc; }
  </style>
</head>
<body>
  <header>
    <h1>é›™äººç¬‘å®¹å°æ±ºï¼ˆåœ“ç’°é¡¯ç¤ºï½œ2Ã—3 ç…§ç‰‡ç‰†ï¼‰</h1>
  </header>

  <div class="wrap">
    <div class="grid">
      <!-- å·¦ï¼šç›¸æ©Ÿèˆ‡ç–Šåœ– -->
      <section class="card">
        <div class="row" style="justify-content: space-between; margin-bottom:10px;">
          <div class="row">
            <button id="btnStart" class="btn">â–¶ é–‹å§‹åµæ¸¬</button>
            <button id="btnStop" class="btn" disabled>â¹ åœæ­¢</button>
            <button id="btnRound" class="btn" disabled>ğŸ é–‹å§‹å›åˆ</button>
            <label class="pill"><input type="checkbox" id="chkRear" /> ä½¿ç”¨å¾Œé¡é ­</label>
            <label class="pill"><input type="checkbox" id="chkMirror" checked /> é¡åƒè¦–åœ–</label>
            <label class="pill">å¾®ç¬‘æ¨¡å¼
              <select id="selMode">
                <option value="strict">åš´æ ¼</option>
                <option value="medium" selected>ä¸­ç­‰</option>
                <option value="lenient">å¯¬é¬†</option>
              </select>
            </label>
          </div>
          <div class="pill">ç•«é¢åƒ…é¡¯ç¤ºï¼š<b>ç¬‘å®¹åœ“ç’°ï¼‹ç™¾åˆ†æ¯”</b>ï¼›é”æ¨™å³æ‹ï¼Œå†·å» 3 ç§’ã€‚</div>
        </div>

        <div class="videoWrap">
          <video id="video" playsinline muted></video>
          <canvas id="canvas" class="overlay"></canvas>
        </div>

        <div class="hud">
          <div class="hudItem">FPS<br><b id="statFps">â€“</b></div>
          <div class="hudItem">åµæ¸¬è‡‰éƒ¨<br><b id="statFaces">â€“</b></div>
          <div class="hudItem">ç‹€æ…‹<br><b id="statTimer">â€”</b></div>
        </div>
      </section>

      <!-- å³ï¼šç…§ç‰‡ç‰† -->
      <aside class="card">
        <h3 style="margin:6px 0 10px;">ç…§ç‰‡ç‰†ï¼ˆ2Ã—3ï¼Œå¾ªç’°è¦†å¯«ï¼‰</h3>
        <div id="gallery" class="gallery"></div>
      </aside>
    </div>

    <section class="card">
      <h3 style="margin:6px 0 12px;">ç´€éŒ„æ¢ä»¶</h3>
      <ul>
        <li>ä¾ã€Œåš´æ ¼ï¼ä¸­ç­‰ï¼å¯¬é¬†ã€æ¨¡å¼åˆ¤æ–·å¾®ç¬‘æ˜¯å¦é”æ¨™ã€‚</li>
        <li>å­˜åœ–å¾Œ<b>æš«åœ 3 ç§’</b>å†ç¹¼çºŒåµæ¸¬ã€‚</li>
      </ul>
    </section>
  </div>

  <div id="toast">æç¤º</div>
  <footer style="text-align:center; color:#8ea1c0; font-size:12px; padding: 8px 0 24px;">
    æ¨¡å‹åœ¨æœ¬æ©Ÿç«¯åŸ·è¡Œï¼›ç›¸æ©Ÿç•«é¢ä¸æœƒä¸Šå‚³ä¼ºæœå™¨ã€‚
  </footer>

  <!-- ä¾è³´ -->
  <script src="https://cdn.jsdelivr.net/npm/@tensorflow/tfjs@4.15.0/dist/tf.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/@vladmandic/face-api/dist/face-api.min.js"></script>

  <script>
    // ==== DOM ====
    const video = document.getElementById('video');
    const canvas = document.getElementById('canvas');
    const ctx = canvas.getContext('2d');

    const btnStart = document.getElementById('btnStart');
    const btnStop  = document.getElementById('btnStop');
    const btnRound = document.getElementById('btnRound');
    const chkRear  = document.getElementById('chkRear');
    const chkMirror= document.getElementById('chkMirror');
    const selMode  = document.getElementById('selMode');

    const statFps   = document.getElementById('statFps');
    const statFaces = document.getElementById('statFaces');
    const statTimer = document.getElementById('statTimer');

    const galleryEl = document.getElementById('gallery');
    const toast = document.getElementById('toast');

    // ==== ç‹€æ…‹ ====
    let running=false, stream=null, detections=[];
    let lastFrameTime=performance.now(), fps=0;
    let detectOptions=null, modelsLoaded=false;
    let DETECT_MS=140, lastDetectAt=0;

    // ç…§ç‰‡ç‰†
    const GALLERY_SLOTS=6; let galleryIdx=0;

    // å†·å»
    const COOLDOWN_MS=3000; let cooldownUntil=0;
    const inCooldown = ()=> performance.now() < cooldownUntil;

    // ä¸‰æ®µé–€æª»
    const SMILE_PRESETS = {
      strict:  { happy:0.85, wMin:0.30, hMin:0.09 },
      medium:  { happy:0.70, wMin:0.28, hMin:0.07 },
      lenient: { happy:0.55, wMin:0.26, hMin:0.05 }
    };
    const getPreset = ()=> SMILE_PRESETS[selMode.value] || SMILE_PRESETS.medium;

    // ==== UI ====
    function showToast(msg, ms=1200){
      toast.textContent = msg; toast.classList.add('show');
      clearTimeout(showToast._t); showToast._t=setTimeout(()=>toast.classList.remove('show'), ms);
    }
    function resizeCanvas(){
      const w=video.videoWidth||640, h=video.videoHeight||480;
      canvas.width=w; canvas.height=h;
      ctx.textAlign='center'; ctx.textBaseline='middle';
    }
    function applyMirror(){ [video, canvas].forEach(el=> el.classList.toggle('mirror', chkMirror.checked)); }
    function calcDetectParams(){
      const minDim=Math.min(video.videoWidth, video.videoHeight) || 480;
      const sz = minDim>=900?320:(minDim>=600?224:160);
      detectOptions=new faceapi.TinyFaceDetectorOptions({ inputSize:sz, scoreThreshold:0.5 });
      DETECT_MS = (sz>=320)?160:(sz>=224?140:120);
    }

    // ==== ç…§ç‰‡ç‰† ====
    function initGallery(){
      galleryEl.innerHTML='';
      for(let i=0;i<GALLERY_SLOTS;i++){
        const cell=document.createElement('div'); cell.className='shot';
        const img=document.createElement('img'); img.alt=`shot-${i+1}`;
        const cap=document.createElement('div'); cap.className='cap'; cap.textContent='â€”';
        cell.appendChild(img); cell.appendChild(cap);
        galleryEl.appendChild(cell);
      }
      galleryIdx=0;
    }
    function pushGallery(dataUrl, meta){
      const cells=galleryEl.querySelectorAll('.shot');
      if(!cells.length) return;
      const cell=cells[galleryIdx % GALLERY_SLOTS];
      const img=cell.querySelector('img');
      const cap=cell.querySelector('.cap');
      let loaded=false;
      img.onload=()=>{ loaded=true; img.style.opacity='1'; };
      img.style.opacity='0'; img.src=''; requestAnimationFrame(()=>{ img.src=dataUrl; });
      cap.textContent=meta;
      galleryIdx++;
      setTimeout(()=>{ if(!loaded) img.style.opacity='1'; }, 300);
    }

    // ==== Camera / Models ====
    async function startCamera(){
      if(!navigator.mediaDevices?.getUserMedia){ showToast('æ­¤ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©Ÿå­˜å–'); return; }
      const facingMode = chkRear.checked ? 'environment' : 'user';
      const constraints={ video:{facingMode, width:{ideal:1280}, height:{ideal:720}}, audio:false };
      stream = await navigator.mediaDevices.getUserMedia(constraints);
      video.srcObject=stream; await video.play();
      resizeCanvas(); applyMirror(); calcDetectParams();
    }
    function stopCamera(){
      if(stream){ stream.getTracks().forEach(t=>t.stop()); stream=null; }
      video.srcObject=null;
    }
    async function loadModels(){
      if(modelsLoaded) return;
      const URL='https://cdn.jsdelivr.net/npm/@vladmandic/face-api/model/';
      await faceapi.nets.tinyFaceDetector.loadFromUri(URL);
      await faceapi.nets.faceLandmark68Net.loadFromUri(URL);
      await faceapi.nets.faceExpressionNet.loadFromUri(URL);
      modelsLoaded=true;
    }

    // ==== åˆ¤æ–·å¾®ç¬‘ï¼ˆåƒ…ç”¨æ–¼è§¸ç™¼èˆ‡åœ“ç’°ç™¾åˆ†æ¯”ï¼‰ ====
    function isSmileByMode(det){
      if(!det) return {ok:false, happy:0};
      const P = getPreset();
      const happy = Math.max(0, Math.min(1, (det.expressions?.happy)||0));
      const lm = det.landmarks.positions;
      const d = (i,j)=> Math.hypot(lm[i].x - lm[j].x, lm[i].y - lm[j].y);

      const mouthW = d(48,54);
      const mouthH = d(51,57);
      const faceW  = d(0,16);
      const faceH  = Math.hypot(lm[8].x - lm[27].x, lm[8].y - lm[27].y) * 1.5;

      const wNorm = mouthW / (faceW + 1e-6);
      const hNorm = mouthH / (faceH + 1e-6);

      const ok = (happy >= P.happy) && (wNorm >= P.wMin) && (hNorm >= P.hMin);
      return {ok, happy};
    }

    // ==== åœ“ç’°ï¼ˆè‡‰ä¸Šæ–¹ï¼Œç„¡æ–¹æ¡†ï¼ç„¡æ¢å½¢åœ–ï¼‰ ====
    function drawRing(cx, cy, r, pct, ok){
      const line=Math.max(6, Math.round(r*0.10));
      // èƒŒæ™¯åœˆ
      ctx.lineWidth=line; ctx.strokeStyle='rgba(120,150,200,.35)';
      ctx.beginPath(); ctx.arc(cx, cy, r, 0, Math.PI*2); ctx.stroke();
      // é€²åº¦
      const a0=-Math.PI/2, a1=a0 + pct*2*Math.PI;
      ctx.strokeStyle = ok? 'rgba(53,224,133,.95)' : 'rgba(90,120,181,.95)';
      ctx.lineCap='round'; ctx.beginPath(); ctx.arc(cx, cy, r, a0, a1); ctx.stroke();

      // === é¡åƒæ•¸å­—ï¼šåªé¡åƒæ–‡å­—ï¼Œä¸é¡åƒåœ“ç’° ===
      ctx.save();
      ctx.translate(cx*2, 0);       // ä»¥ cx ç‚ºé¡åƒè»¸
      ctx.scale(-1, 1);             // æ°´å¹³é¡åƒ
      ctx.fillStyle = ok? '#caffdb' : '#d7e2ff';
      ctx.textAlign = 'center';
      ctx.textBaseline = 'middle';
      ctx.font = `bold ${Math.round(r*0.9)}px "Microsoft JhengHei", system-ui`;
      ctx.fillText(Math.round(pct*100), cx, cy+1);
      ctx.font = `bold ${Math.round(r*0.35)}px "Microsoft JhengHei", system-ui`;
      ctx.fillText('%', cx + r*0.7, cy - r*0.15);
      ctx.restore();
    }
    function drawFaceRings(){
      const faces=(detections||[]).slice().sort((a,b)=> a.detection.box.x - b.detection.box.x);
      faces.forEach(det=>{
        const b=det.detection.box;
        const cx=b.x + b.width/2;
        const r = Math.max(22, Math.min(64, Math.min(b.width, b.height) * 0.35));
        let cy = b.y - r*0.6; if(cy - r < 6) cy = r + 6;
        const {ok, happy}=isSmileByMode(det);
        drawRing(cx, cy, r, Math.max(0, Math.min(1, happy)), ok);
      });
    }

    // ==== æ“·å–è‡‰ï¼ˆèˆ‡é¡åƒä¸€è‡´ï¼‰ ====
    function captureFace(det){
      const b=det.detection.box, expand=0.25;
      const cx=b.x+b.width/2, cy=b.y+b.height/2;
      const w=b.width*(1+expand), h=b.height*(1+expand);
      let x=Math.max(0, cx-w/2), y=Math.max(0, cy-h/2);
      let x2=Math.min(canvas.width, x+w), y2=Math.min(canvas.height, y+h);
      const cropW=Math.max(1, Math.floor(x2-x)), cropH=Math.max(1, Math.floor(y2-y));

      const off=document.createElement('canvas'); off.width=canvas.width; off.height=canvas.height;
      const octx=off.getContext('2d');
      const mirrored = chkMirror.checked;
      if(mirrored){ octx.translate(off.width,0); octx.scale(-1,1); }
      octx.drawImage(video, 0,0,off.width, off.height);
      if(mirrored){ x = off.width - (x + cropW); }

      const out=document.createElement('canvas'); out.width=cropW; out.height=cropH;
      out.getContext('2d').drawImage(off, x,y,cropW,cropH, 0,0,cropW,cropH);
      return out.toDataURL('image/png');
    }

    // ==== åµæ¸¬ï¼å­˜åœ– ====
    async function maybeDetect(now){
      if(!running || !modelsLoaded) return;
      if(inCooldown()) return;
      if(now - lastDetectAt < DETECT_MS) return;
      lastDetectAt=now;

      try{
        detections = await faceapi
          .detectAllFaces(video, detectOptions)
          .withFaceLandmarks()
          .withFaceExpressions();
        statFaces.textContent = detections.length;

        if(detections.length>0){
          // å¾é”æ¨™è€…ä¸­æŒ‘ happy æœ€é«˜è€…
          let best=null, bestHappy=-1, who='P?';
          const faces=detections.slice().sort((a,b)=> a.detection.box.x - b.detection.box.x);
          faces.forEach((det, idx)=>{
            const {ok, happy}=isSmileByMode(det);
            if(ok && happy>bestHappy){ best=det; bestHappy=happy; who=(idx===0?'P1':'P2'); }
          });
          if(best){
            const dataUrl=captureFace(best);
            pushGallery(dataUrl, `${who} Â· ${new Date().toLocaleTimeString()}`);
            cooldownUntil = performance.now() + COOLDOWN_MS;
            showToast('å·²è¨˜éŒ„ç¬‘å®¹ âœ“ æš«åœ 3 ç§’');
          }
        }
      }catch(e){ console.warn('detect error', e); }
    }

    // ==== ä¸»è¿´åœˆï¼ˆåªç•«åœ“ç’°ï¼‰ ====
    function loop(now){
      if(!running) return;
      const dt=now-lastFrameTime; lastFrameTime=now;
      fps=Math.round(1000/Math.max(1,dt)); statFps.textContent=fps;

      // å†·å»ç‹€æ…‹
      if(inCooldown()){
        const left = Math.max(0, cooldownUntil - performance.now());
        statTimer.textContent = `æš«åœ ${(left/1000).toFixed(1)}s`;
      } else {
        statTimer.textContent = 'â€”';
      }

      ctx.clearRect(0,0,canvas.width, canvas.height);
      drawFaceRings(); // â˜… åªç•«åœ“ç’°ï¼Œæ²’æœ‰æ–¹æ¡†ï¼æ©«æ¢åœ–

      requestAnimationFrame(loop);
      maybeDetect(now);
    }

    // ==== å•Ÿåœ ====
    async function startAll(){
      if(running) return;
      try{
        btnStart.disabled=true; btnStop.disabled=true; btnRound.disabled=true;
        initGallery(); showToast('è¼‰å…¥æ¨¡å‹ä¸­â€¦');
        await startCamera(); await loadModels();
        // é ç†±
        try{
          await faceapi.detectAllFaces(video, new faceapi.TinyFaceDetectorOptions({ inputSize:160, scoreThreshold:0.5 }))
            .withFaceLandmarks().withFaceExpressions();
        }catch(e){}
        running=true; btnStop.disabled=false; btnRound.disabled=false;
        showToast('é–‹å§‹åµæ¸¬');
        lastFrameTime=performance.now();
        requestAnimationFrame(loop);
      }catch(e){
        console.error(e);
        showToast('å•Ÿå‹•å¤±æ•—ï¼Œè«‹æª¢æŸ¥ç›¸æ©Ÿæ¬Šé™/ç¶²è·¯');
        btnStart.disabled=false; btnStop.disabled=true; btnRound.disabled=true;
        stopAll(true);
      }
    }
    function stopAll(silent=false){
      if(!silent) showToast('å·²åœæ­¢');
      running=false; stopCamera();
      statFps.textContent='â€“'; statFaces.textContent='â€“';
      ctx.clearRect(0,0,canvas.width, canvas.height);
      btnStart.disabled=false; btnStop.disabled=true; btnRound.disabled=true;
    }

    // ==== äº‹ä»¶ ====
    btnStart.addEventListener('click', startAll);
    btnStop.addEventListener('click', ()=> stopAll());
    btnRound.addEventListener('click', ()=> showToast('å›åˆåŠŸèƒ½æœªæ”¹å‹•ï¼ˆè¦–è¦ºä¸é¡¯ç¤ºæ–¹æ¡†/æ©«æ¢ï¼‰'));
    chkRear.addEventListener('change', async ()=>{ if(running){ try{ await startCamera(); }catch(e){} }});
    chkMirror.addEventListener('change', applyMirror);
    window.addEventListener('resize', ()=>{ if(video.videoWidth){ resizeCanvas(); calcDetectParams(); }});
    video.addEventListener('loadedmetadata', ()=>{ resizeCanvas(); calcDetectParams(); });

    if(!('mediaDevices' in navigator && 'getUserMedia' in navigator.mediaDevices)){
      showToast('æ­¤ç€è¦½å™¨ä¸æ”¯æ´æ”å½±æ©Ÿå­˜å–'); btnStart.disabled=true;
    }
  </script>
</body>
</html>
